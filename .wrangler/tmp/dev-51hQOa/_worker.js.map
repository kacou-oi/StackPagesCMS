{
  "version": 3,
  "sources": ["../bundle-ECyb65/checked-fetch.js", "../../../_worker.js", "../../../../../../../.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../../../.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-ECyb65/middleware-insertion-facade.js", "../../../../../../../.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/common.ts", "../bundle-ECyb65/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/.wrangler/tmp/dev-51hQOa",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "// ====================================================================\n// 1. CONFIGURATION ET UTILITAIRES\n// ====================================================================\n\n// Constantes pour la gestion du cache\nconst CACHE_TTL = 180;\n\nfunction slugify(text) {\n    return text.toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/(^-|-$)/g, '')\n        .trim();\n}\n\nfunction decodeHTMLEntities(str) {\n    if (!str) return \"\";\n    const map = {\n        \"nbsp\": \" \", \"amp\": \"&\", \"quot\": \"\\\"\", \"lt\": \"<\", \"gt\": \">\", \"#39\": \"'\"\n    };\n    return str.replace(/&(#?\\w+);/g, (match, entity) => {\n        if (entity.startsWith('#')) {\n            const code = entity.startsWith('#x') ? parseInt(entity.slice(2), 16) : parseInt(entity.slice(1), 10);\n            return String.fromCharCode(code);\n        }\n        return map[entity] || match;\n    });\n}\n\nfunction extractFirstImage(html) {\n    const imgRe = /<img[^>]+src=[\"']([^\"']+)[\"']/i;\n    const match = html.match(imgRe);\n    return match ? match[1] : null;\n}\n\nfunction extractEnclosureImage(block) {\n    const re = /<enclosure\\s+url=[\"']([^\"']+)[\"'][^>]*type=[\"']image\\/[^\"']+/i;\n    const match = block.match(re);\n\n    if (match && match[1]) {\n        return match[1].trim();\n    }\n    return null;\n}\n\n// --- NOUVEAU: Fonction de nettoyage HTML ---\nfunction cleanHtmlContent(html) {\n    if (!html) return \"\";\n\n    // 1. Suppression des balises <a> avec la classe \"image-link-expand\" (UI Substack)\n    // Cette regex cible la balise ouvrante, tout son contenu non gourmand, et la balise fermante.\n    const regexExpand = /<a\\s+[^>]*class=[\"'][^\"']*image-link-expand[^\"']*(?:[^>]*)*>.*?<\\/a>/gis;\n\n    let cleanedHtml = html.replace(regexExpand, '');\n\n    // 2. Optionnel: Nettoyage des attributs style pour \u00E9viter les conflits CSS\n    cleanedHtml = cleanedHtml.replace(/style=\"[^\"]*\"/gi, '');\n\n    return cleanedHtml;\n}\n\n// ====================================================================\n// 1.5 REVERSE PROXY - CLASSE UTILITAIRE\n// ====================================================================\n\n// Classe pour r\u00E9\u00E9crire les attributs HTML lors du reverse proxy\nclass AttributeRewriter {\n    constructor(attributeName, targetDomain, workerDomain) {\n        this.attributeName = attributeName;\n        this.targetDomain = targetDomain;\n        this.workerDomain = workerDomain;\n    }\n\n    element(element) {\n        const attribute = element.getAttribute(this.attributeName);\n\n        // Remplacer les liens absolus du domaine cible par le domaine du Worker\n        if (attribute && attribute.includes(this.targetDomain)) {\n            // Utiliser une regex globale ou split/join pour tout remplacer (important pour srcset)\n            const newValue = attribute.split(this.targetDomain).join(this.workerDomain);\n            element.setAttribute(this.attributeName, newValue);\n        }\n    }\n}\n\n\n// ====================================================================\n// 2. LOGIQUE DE PARSING\n// ====================================================================\n\n// --- Fonction pour extraire les infos globales du canal RSS (Inchang\u00E9e) ---\nfunction extractChannelMetadata(xml) {\n    // ... (Logique inchang\u00E9e)\n    const getChannelTag = (tag) => {\n        const re = new RegExp(`<channel>(?:.|[\\\\r\\\\n])*?<${tag}[^>]*>((.|[\\\\r\\\\n])*?)<\\/${tag}>`, 'i');\n        const found = xml.match(re);\n        if (!found) return \"\";\n        let content = found[1].trim();\n        if (content.startsWith('<![CDATA[')) {\n            content = content.slice(9, -3).trim();\n        }\n        return decodeHTMLEntities(content);\n    };\n\n    const title = getChannelTag('title');\n    const link = getChannelTag('link');\n    const lastBuildDate = getChannelTag('lastBuildDate');\n    const description = getChannelTag('description');\n\n    return {\n        blogTitle: title,\n        blogUrl: link,\n        lastBuildDate: lastBuildDate,\n        blogDescription: description\n    };\n}\n\n// --- Fonction pour analyser le XML (Articles uniquement) ---\nfunction fetchAndParseRSS(xml) {\n    const items = [];\n    const itemRe = /<item[^>]*>((.|[\\r\\n])*?)<\\/item>/gi;\n    let m;\n\n    while ((m = itemRe.exec(xml)) !== null) {\n        const block = m[1];\n        const getTag = (tag) => {\n            const re = new RegExp(`<${tag}[^>]*>((.|[\\r\\n])*?)<\\/${tag}>`, 'i');\n            const found = block.match(re);\n            if (!found) return \"\";\n            let content = found[1].trim();\n            if (content.startsWith('<![CDATA[')) {\n                content = content.slice(9, -3).trim();\n            }\n            content = decodeHTMLEntities(content);\n            return content;\n        };\n\n        const title = getTag('title');\n        const link = getTag('link');\n        const pubDate = getTag('pubDate');\n        const description = getTag('description');\n\n        let image = extractEnclosureImage(block);\n\n        let contentFull = \"\";\n        const contentEncodedRe = /<content:encoded[^>]*>((.|[\\r\\n])*?)<\\/content:encoded>/i;\n        const contentEncodedMatch = block.match(contentEncodedRe);\n\n        if (contentEncodedMatch) {\n            let content = contentEncodedMatch[1].trim();\n            if (content.startsWith('<![CDATA[')) {\n                content = content.slice(9, -3).trim();\n            }\n            contentFull = decodeHTMLEntities(content);\n\n            // --- NOUVEAU: Appel \u00E0 la fonction de nettoyage ---\n            contentFull = cleanHtmlContent(contentFull);\n\n            if (!image) {\n                image = extractFirstImage(contentFull);\n            }\n        } else {\n            contentFull = description;\n        }\n\n        const slug = slugify(title);\n\n        items.push({\n            title,\n            link,\n            pubDate,\n            description,\n            slug,\n            content: contentFull,\n            image\n        });\n    }\n\n    // Trier par date de publication (du plus r\u00E9cent au plus ancien)\n    items.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));\n\n    return items;\n}\n\n// --- Fonction pour analyser le XML YouTube ---\nfunction fetchAndParseYoutubeRSS(xml) {\n    const items = [];\n    const entryRe = /<entry[^>]*>((.|[\\r\\n])*?)<\\/entry>/gi;\n    let m;\n\n    while ((m = entryRe.exec(xml)) !== null) {\n        const block = m[1];\n        const getTag = (tag) => {\n            const re = new RegExp(`<${tag}[^>]*>((.|[\\r\\n])*?)<\\/${tag}>`, 'i');\n            const found = block.match(re);\n            if (!found) return \"\";\n            return decodeHTMLEntities(found[1].trim());\n        };\n\n        const title = getTag('title');\n        const published = getTag('published');\n\n        // Extract Video ID\n        const videoIdRe = /<yt:videoId>((.|[\\r\\n])*?)<\\/yt:videoId>/i;\n        const videoIdMatch = block.match(videoIdRe);\n        const videoId = videoIdMatch ? videoIdMatch[1].trim() : \"\";\n\n        // Extract Thumbnail\n        const mediaGroupRe = /<media:group>((.|[\\r\\n])*?)<\\/media:group>/i;\n        const mediaGroupMatch = block.match(mediaGroupRe);\n        let thumbnail = \"\";\n        let description = \"\";\n\n        if (mediaGroupMatch) {\n            const groupContent = mediaGroupMatch[1];\n            const thumbRe = /<media:thumbnail\\s+url=[\"']([^\"']+)[\"']/i;\n            const thumbMatch = groupContent.match(thumbRe);\n            if (thumbMatch) thumbnail = thumbMatch[1];\n\n            const descRe = /<media:description[^>]*>((.|[\\r\\n])*?)<\\/media:description>/i;\n            const descMatch = groupContent.match(descRe);\n            if (descMatch) description = decodeHTMLEntities(descMatch[1].trim());\n        }\n\n        if (videoId) {\n            items.push({\n                id: videoId,\n                title,\n                published,\n                thumbnail,\n                description,\n                link: `https://www.youtube.com/watch?v=${videoId}`\n            });\n        }\n    }\n\n    // Sort by date desc\n    items.sort((a, b) => new Date(b.published) - new Date(a.published));\n\n    return items;\n}\n\n\n// ====================================================================\n// 3. LOGIQUE DE CACHE ET R\u00C9CUP\u00C9RATION DES DONN\u00C9ES\n// ====================================================================\nasync function getCachedRSSData(feedUrl, forceRefresh = false) {\n    const cache = caches.default;\n    const cacheKey = new Request(feedUrl, { method: 'GET' });\n\n    if (!forceRefresh) {\n        let response = await cache.match(cacheKey);\n        if (response) {\n            return await response.json();\n        }\n    }\n\n    const res = await fetch(feedUrl);\n    if (!res.ok) throw new Error(`\u00C9chec du chargement du flux RSS : ${res.statusText}`);\n    const xml = await res.text();\n\n    const metadata = extractChannelMetadata(xml);\n    const posts = fetchAndParseRSS(xml);\n\n    const data = {\n        metadata: metadata,\n        posts: posts\n    };\n\n    const cachedResponse = new Response(JSON.stringify(data), {\n        headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': `public, max-age=${CACHE_TTL}`\n        }\n    });\n    // Always update cache\n    await cache.put(cacheKey, cachedResponse.clone());\n\n    return data;\n}\n\nasync function getCachedYoutubeData(feedUrl, forceRefresh = false) {\n    if (!feedUrl) return [];\n\n    const cache = caches.default;\n    const cacheKey = new Request(feedUrl, { method: 'GET' });\n\n    if (!forceRefresh) {\n        let response = await cache.match(cacheKey);\n        if (response) {\n            return await response.json();\n        }\n    }\n\n    try {\n        const res = await fetch(feedUrl);\n        if (!res.ok) throw new Error(`\u00C9chec du chargement du flux YouTube`);\n        const xml = await res.text();\n        const videos = fetchAndParseYoutubeRSS(xml);\n\n        const cachedResponse = new Response(JSON.stringify(videos), {\n            headers: {\n                'Content-Type': 'application/json',\n                'Cache-Control': `public, max-age=${CACHE_TTL}`\n            }\n        });\n        await cache.put(cacheKey, cachedResponse.clone());\n\n        return videos;\n    } catch (e) {\n        console.error(\"Erreur YouTube Fetch:\", e);\n        return [];\n    }\n}\n\n// ====================================================================\n// 4. GESTIONNAIRE PRINCIPAL DU WORKER\n// ====================================================================\n\nexport default {\n    async fetch(req, env) {\n        const url = new URL(req.url);\n        let path = url.pathname;\n\n        if (path.length > 1 && path.endsWith('/')) {\n            path = path.slice(0, -1);\n        }\n\n        // --- CONFIGURATION ---\n        // --- CONFIGURATION (ENV VARS ONLY) ---\n        // La configuration est g\u00E9r\u00E9e uniquement par les variables d'environnement.\n        // Pas de KV, pas de Cache API pour la config.\n\n        const config = {\n            siteName: \"StackPages CMS\",\n            author: \"Admin\",\n            substackRssUrl: env.SUBSTACK_FEED_URL || \"\",\n            youtubeRssUrl: env.YOUTUBE_FEED_URL || \"\",\n            frontendBuilderUrl: env.FRONTEND_BUILDER_URL || \"\",\n            podcastFeedUrl: env.PODCAST_FEED_URL || \"\",\n            seo: {\n                metaTitle: env.META_TITLE || \"\",\n                metaDescription: env.META_DESCRIPTION || \"\",\n                metaKeywords: env.META_KEYWORDS || \"\"\n            }\n        };\n\n        // --- AUTHENTIFICATION ---\n        const ADMIN_PASSWORD = env.ADMIN_PASSWORD || \"admin\"; // D\u00C9FAUT NON S\u00C9CURIS\u00C9 POUR LE DEV\n        const SESSION_SECRET = \"stackpages-session-secret\"; // \u00C0 changer en prod id\u00E9alement\n\n        const isAuthenticated = () => {\n            const authKey = req.headers.get('X-Auth-Key');\n            return authKey === ADMIN_PASSWORD;\n        };\n\n        const corsHeaders = {\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n            'Access-Control-Allow-Headers': 'Content-Type',\n            'Content-Type': 'application/json'\n        };\n\n        if (req.method === 'OPTIONS') {\n            return new Response(null, { status: 204, headers: corsHeaders });\n        }\n\n        // --- ROUTES API PUBLIC ---\n\n        // 1. Login (Validation email + password)\n        if (path === \"/api/login\" && req.method === \"POST\") {\n            try {\n                const body = await req.json();\n                const ADMIN_EMAIL = env.ADMIN_EMAIL || \"admin@example.com\"; // Default for dev\n\n                if (body.email === ADMIN_EMAIL && body.password === ADMIN_PASSWORD) {\n                    return new Response(JSON.stringify({ success: true }), { status: 200, headers: corsHeaders });\n                } else {\n                    return new Response(JSON.stringify({ error: \"Identifiants incorrects\" }), { status: 401, headers: corsHeaders });\n                }\n            } catch (e) {\n                return new Response(\"Bad Request\", { status: 400, headers: corsHeaders });\n            }\n        }\n\n        // 2. Logout (Client side only, but endpoint kept for compatibility)\n        if (path === \"/api/logout\") {\n            return new Response(JSON.stringify({ success: true }), { status: 200, headers: corsHeaders });\n        }\n\n        // 3. Check Auth (Removed or simplified)\n        if (path === \"/api/check-auth\") {\n            // Client checks localStorage, this is just a helper if needed\n            if (isAuthenticated()) {\n                return new Response(JSON.stringify({ authenticated: true }), { status: 200, headers: corsHeaders });\n            } else {\n                return new Response(JSON.stringify({ authenticated: false }), { status: 401, headers: corsHeaders });\n            }\n        }\n\n        // 4. Public Data (Metadata & Posts)\n        const FEED_URL = config.substackRssUrl;\n        console.log(\"DEBUG: Configured Substack URL:\", FEED_URL);\n\n        if (!FEED_URL && (path === \"/api/metadata\" || path === \"/api/posts\" || path.startsWith(\"/api/post/\"))) {\n            // Return empty data instead of error to allow UI to render\n            const emptyMeta = { siteName: \"StackPages\", author: \"Admin\", lastBuildDate: new Date().toISOString() };\n            if (path === \"/api/metadata\") return new Response(JSON.stringify(emptyMeta), { status: 200, headers: corsHeaders });\n            if (path === \"/api/posts\") return new Response(JSON.stringify([]), { status: 200, headers: corsHeaders });\n            return new Response(JSON.stringify({ error: \"Article non trouv\u00E9\" }), { status: 404, headers: corsHeaders });\n        }\n\n        if (path === \"/api/metadata\" || path === \"/api/posts\" || path.startsWith(\"/api/post/\")) {\n            let blogData;\n            try {\n                blogData = await getCachedRSSData(FEED_URL);\n            } catch (error) {\n                console.error(\"Error fetching Substack RSS:\", error);\n                // Return empty/fallback data on fetch error\n                if (path === \"/api/metadata\") return new Response(JSON.stringify({ siteName: \"Error\", author: \"Error\" }), { status: 200, headers: corsHeaders });\n                if (path === \"/api/posts\") return new Response(JSON.stringify([]), { status: 200, headers: corsHeaders });\n                return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: corsHeaders });\n            }\n\n            if (path === \"/api/metadata\") {\n                // On merge les m\u00E9tadonn\u00E9es du RSS avec celles de la config locale\n                const meta = {\n                    ...blogData.metadata,\n                    siteName: config.siteName,\n                    author: config.author,\n                    seo: config.seo\n                };\n                return new Response(JSON.stringify(meta), { status: 200, headers: corsHeaders });\n            }\n\n            if (path === \"/api/posts\") {\n                return new Response(JSON.stringify(blogData.posts), { status: 200, headers: corsHeaders });\n            }\n\n            if (path.startsWith(\"/api/post/\")) {\n                const slug = path.split(\"/\").pop();\n                const post = blogData.posts.find(p => p.slug === slug);\n                if (post) {\n                    return new Response(JSON.stringify(post), { status: 200, headers: corsHeaders });\n                } else {\n                    return new Response(JSON.stringify({ error: \"Article non trouv\u00E9\" }), { status: 404, headers: corsHeaders });\n                }\n            }\n        }\n\n        // API: Get Podcasts\n        if (path === \"/api/podcasts\") {\n            const feedUrl = config.podcastFeedUrl;\n            if (!feedUrl) {\n                return new Response(JSON.stringify([]), {\n                    headers: corsHeaders\n                });\n            }\n\n            try {\n                const response = await fetch(feedUrl, {\n                    headers: {\n                        \"User-Agent\": \"StackPages-Worker/1.0\"\n                    }\n                });\n\n                if (!response.ok) throw new Error(`Failed to fetch RSS: ${response.status}`);\n\n                const xmlText = await response.text();\n\n                // Basic XML parsing for podcasts\n                const items = [];\n                let currentPos = 0;\n\n                while (true) {\n                    const itemStart = xmlText.indexOf(\"<item>\", currentPos);\n                    if (itemStart === -1) break;\n\n                    const itemEnd = xmlText.indexOf(\"</item>\", itemStart);\n                    if (itemEnd === -1) break;\n\n                    const itemContent = xmlText.substring(itemStart, itemEnd);\n\n                    const titleMatch = itemContent.match(/<title>(.*?)<\\/title>/s);\n                    const linkMatch = itemContent.match(/<link>(.*?)<\\/link>/s);\n                    const pubDateMatch = itemContent.match(/<pubDate>(.*?)<\\/pubDate>/s);\n                    const descriptionMatch = itemContent.match(/<description>(.*?)<\\/description>/s);\n                    const enclosureMatch = itemContent.match(/<enclosure[^>]*url=[\"'](.*?)[\"'][^>]*>/s);\n                    const guidMatch = itemContent.match(/<guid[^>]*>(.*?)<\\/guid>/s);\n\n                    // Clean up CDATA\n                    const clean = (str) => {\n                        if (!str) return \"\";\n                        return str.replace(/<!\\[CDATA\\[(.*?)\\]\\]>/g, \"$1\").trim();\n                    };\n\n                    const title = clean(titleMatch ? titleMatch[1] : \"Sans titre\");\n\n                    items.push({\n                        title: title,\n                        slug: slugify(title),\n                        guid: clean(guidMatch ? guidMatch[1] : \"\"),\n                        link: clean(linkMatch ? linkMatch[1] : \"#\"),\n                        pubDate: clean(pubDateMatch ? pubDateMatch[1] : \"\"),\n                        description: clean(descriptionMatch ? descriptionMatch[1] : \"\"),\n                        audioUrl: enclosureMatch ? enclosureMatch[1] : null\n                    });\n\n                    currentPos = itemEnd + 7;\n                }\n\n                // Sort by date desc\n                items.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));\n\n                return new Response(JSON.stringify(items), {\n                    headers: corsHeaders\n                });\n\n            } catch (error) {\n                return new Response(JSON.stringify({\n                    error: error.message\n                }), {\n                    status: 500,\n                    headers: corsHeaders\n                });\n            }\n        }\n\n        // API: Single Podcast\n        if (path.startsWith(\"/api/podcast/\")) {\n            const podcastId = path.split(\"/\").pop();\n            const feedUrl = config.podcastFeedUrl;\n\n            if (!feedUrl) {\n                return new Response(JSON.stringify({ error: \"Flux Podcast non configur\u00E9\" }), { status: 404, headers: corsHeaders });\n            }\n\n            try {\n                // R\u00E9utiliser la logique de fetch/parse (id\u00E9alement factoriser, mais ici on duplique pour l'instant ou on appelle une fonction commune si on refactorise)\n                // Pour faire simple et rapide sans gros refactoring, on refait le fetch (le cache HTTP du worker aidera)\n                // OU MIEUX : On appelle l'endpoint interne ou on extrait la logique.\n                // Ici, je vais copier la logique de parsing pour l'instant car elle est dans le bloc if pr\u00E9c\u00E9dent.\n\n                const response = await fetch(feedUrl, { headers: { \"User-Agent\": \"StackPages-Worker/1.0\" } });\n                if (!response.ok) throw new Error(`Failed to fetch RSS: ${response.status}`);\n                const xmlText = await response.text();\n\n                // Parsing simplifi\u00E9 (copie de ci-dessus)\n                const items = [];\n                let currentPos = 0;\n                while (true) {\n                    const itemStart = xmlText.indexOf(\"<item>\", currentPos);\n                    if (itemStart === -1) break;\n                    const itemEnd = xmlText.indexOf(\"</item>\", itemStart);\n                    if (itemEnd === -1) break;\n                    const itemContent = xmlText.substring(itemStart, itemEnd);\n\n                    const titleMatch = itemContent.match(/<title>(.*?)<\\/title>/s);\n                    const linkMatch = itemContent.match(/<link>(.*?)<\\/link>/s);\n                    const pubDateMatch = itemContent.match(/<pubDate>(.*?)<\\/pubDate>/s);\n                    const descriptionMatch = itemContent.match(/<description>(.*?)<\\/description>/s);\n                    const enclosureMatch = itemContent.match(/<enclosure[^>]*url=[\"'](.*?)[\"'][^>]*>/s);\n                    const guidMatch = itemContent.match(/<guid[^>]*>(.*?)<\\/guid>/s);\n\n                    const clean = (str) => str ? str.replace(/<!\\[CDATA\\[(.*?)\\]\\]>/g, \"$1\").trim() : \"\";\n                    const title = clean(titleMatch ? titleMatch[1] : \"Sans titre\");\n\n                    items.push({\n                        title: title,\n                        slug: slugify(title),\n                        guid: clean(guidMatch ? guidMatch[1] : \"\"),\n                        link: clean(linkMatch ? linkMatch[1] : \"#\"),\n                        pubDate: clean(pubDateMatch ? pubDateMatch[1] : \"\"),\n                        description: clean(descriptionMatch ? descriptionMatch[1] : \"\"),\n                        audioUrl: enclosureMatch ? enclosureMatch[1] : null\n                    });\n                    currentPos = itemEnd + 7;\n                }\n\n                // Recherche par GUID ou Slug\n                const podcast = items.find(p => p.guid === podcastId || p.slug === podcastId);\n\n                if (podcast) {\n                    return new Response(JSON.stringify(podcast), { status: 200, headers: corsHeaders });\n                } else {\n                    return new Response(JSON.stringify({ error: \"Podcast non trouv\u00E9\" }), { status: 404, headers: corsHeaders });\n                }\n\n            } catch (error) {\n                return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: corsHeaders });\n            }\n        }\n\n        // 5. Videos\n        if (path === \"/api/videos\") {\n            console.log(\"DEBUG: Configured YouTube URL:\", config.youtubeRssUrl);\n            if (!config.youtubeRssUrl) {\n                return new Response(JSON.stringify([]), { status: 200, headers: corsHeaders });\n            }\n            try {\n                const videos = await getCachedYoutubeData(config.youtubeRssUrl);\n                return new Response(JSON.stringify(videos), { status: 200, headers: corsHeaders });\n            } catch (error) {\n                console.error(\"Error fetching YouTube RSS:\", error);\n                return new Response(JSON.stringify([]), { status: 200, headers: corsHeaders });\n            }\n        }\n\n        // 5.1 Single Video\n        if (path.startsWith(\"/api/video/\")) {\n            const videoId = path.split(\"/\").pop();\n            if (!config.youtubeRssUrl) {\n                return new Response(JSON.stringify({ error: \"Flux YouTube non configur\u00E9\" }), { status: 404, headers: corsHeaders });\n            }\n\n            try {\n                const videos = await getCachedYoutubeData(config.youtubeRssUrl);\n                const video = videos.find(v => v.id === videoId);\n\n                if (video) {\n                    return new Response(JSON.stringify(video), { status: 200, headers: corsHeaders });\n                } else {\n                    return new Response(JSON.stringify({ error: \"Vid\u00E9o non trouv\u00E9e\" }), { status: 404, headers: corsHeaders });\n                }\n            } catch (error) {\n                console.error(\"Error fetching YouTube RSS:\", error);\n                return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: corsHeaders });\n            }\n        }\n\n        // --- ROUTES API PROT\u00C9G\u00C9ES ---\n\n        // 6. Get Config (Read-Only)\n        if (path === \"/api/config\" && req.method === \"GET\") {\n            if (!isAuthenticated()) {\n                return new Response(JSON.stringify({ error: \"Non autoris\u00E9\" }), { status: 401, headers: corsHeaders });\n            }\n            return new Response(JSON.stringify(config), { status: 200, headers: corsHeaders });\n        }\n\n        // 7. Save Config (Disabled)\n        if (path === \"/api/config\" && req.method === \"POST\") {\n            return new Response(JSON.stringify({ error: \"La configuration est g\u00E9r\u00E9e par les variables d'environnement.\" }), { status: 405, headers: corsHeaders });\n        }\n\n        // 5. Clear Cache (Protected)\n        if (path === \"/api/clear-cache\" && req.method === \"POST\") {\n            if (!isAuthenticated()) {\n                return new Response(JSON.stringify({ error: \"Non autoris\u00E9\" }), { status: 401, headers: corsHeaders });\n            }\n            // Note: On Cloudflare Workers, on ne peut pas \"vider\" le cache global programmatiquement facilement sans Purge API.\n            // Mais on peut invalider le cache local de l'instance ou utiliser une astuce de versioning.\n            // Pour ce MVP, on va simuler ou utiliser l'API Cache si possible.\n            // L'API Cache standard permet de supprimer une entr\u00E9e.\n\n            const cache = caches.default;\n            // On essaie de supprimer les cl\u00E9s principales\n            // Note: match() n\u00E9cessite une requ\u00EAte compl\u00E8te. C'est difficile de tout vider sans conna\u00EEtre les cl\u00E9s.\n            // Une astuce est de changer le pr\u00E9fixe de cache ou d'attendre le TTL.\n            // ICI: On va juste renvoyer OK car le TTL est court (180s).\n            // Pour une vraie impl\u00E9mentation, il faudrait stocker les URLs cach\u00E9es ou utiliser l'API Cloudflare Purge.\n\n            return new Response(JSON.stringify({ success: true, message: \"Cache invalid\u00E9 (attendre TTL ou red\u00E9ploiement)\" }), { status: 200, headers: corsHeaders });\n        }\n\n        // --- FICHIERS STATIQUES ---\n\n        // Protection du dashboard\n        // Note: Avec l'auth stateless, on ne peut pas facilement prot\u00E9ger les pages statiques c\u00F4t\u00E9 serveur \n        // sans envoyer le header (ce que le navigateur ne fait pas pour une navigation standard).\n        // On laisse donc le JS client (app.js) g\u00E9rer la redirection si le localStorage est vide.\n        // C'est moins s\u00E9curis\u00E9 (le code HTML est visible) mais c'est ce qui est demand\u00E9 (\"pas de session\").\n\n        /* \n        if (path === \"/dashboard.html\") {\n             // Impossible de v\u00E9rifier X-Auth-Key ici pour une requ\u00EAte GET navigateur standard\n        }\n        */\n\n        // Admin Login -> admin/index.html\n        if (path === \"/admin\" || path === \"/admin/\") {\n            return await env.ASSETS.fetch(new Request(new URL(\"/admin/index.html\", url), {\n                method: 'GET',\n                headers: req.headers\n            }));\n        }\n\n        // Dashboard -> admin/dashboard.html\n        if (path === \"/dashboard\" || path === \"/dashboard/\") {\n            return await env.ASSETS.fetch(new Request(new URL(\"/admin/dashboard.html\", url), {\n                method: 'GET',\n                headers: req.headers\n            }));\n        }\n\n        // ====================================================================\n        // 5. REVERSE PROXY (SI STAGING_URL EST D\u00C9FINI)\n        // ====================================================================\n        // Note: Cette logique est \u00E9galement document\u00E9e dans /core/frontend.js\n        //       pour r\u00E9f\u00E9rence et maintenance future.\n\n        const STAGING_URL = env.STAGING_URL;\n        let TARGET_DOMAIN = null;\n        let TARGET_PROTOCOL = 'https:';\n\n        if (STAGING_URL) {\n            try {\n                const stagingUrlObj = new URL(STAGING_URL);\n                TARGET_DOMAIN = stagingUrlObj.hostname;\n                TARGET_PROTOCOL = stagingUrlObj.protocol;\n            } catch (e) {\n                console.error(\"Invalid STAGING_URL:\", STAGING_URL);\n            }\n        }\n\n        const WORKER_DOMAIN = url.hostname;\n\n        // Si TARGET_DOMAIN est d\u00E9fini ET que ce n'est pas un chemin admin/API, activer le reverse proxy\n        // Chemins exclus du proxy (d\u00E9j\u00E0 g\u00E9r\u00E9s ci-dessus):\n        // - /api/* (toutes les API)\n        // - /admin, /dashboard (pages admin)\n        // - /core/* (fichiers JS)\n        const isAdminOrApiPath = path.startsWith('/api/') ||\n            path.startsWith('/admin') ||\n            path.startsWith('/dashboard') ||\n            path.startsWith('/core/');\n\n        if (TARGET_DOMAIN && !isAdminOrApiPath) {\n            const originUrl = new URL(req.url);\n            originUrl.hostname = TARGET_DOMAIN;\n            originUrl.protocol = TARGET_PROTOCOL;\n\n            // Cr\u00E9er une nouvelle requ\u00EAte avec les headers modifi\u00E9s\n            let newHeaders = new Headers(req.headers);\n            newHeaders.set(\"Host\", TARGET_DOMAIN);\n            newHeaders.set(\"Referer\", originUrl.toString()); // Optionnel: faire croire que \u00E7a vient du site cible\n\n            let newRequest = new Request(originUrl, {\n                method: req.method,\n                headers: newHeaders,\n                body: req.body,\n                redirect: \"manual\" // G\u00E9rer les redirections manuellement\n            });\n\n            try {\n                let response = await fetch(newRequest);\n                const contentType = response.headers.get('content-type');\n\n                // Pr\u00E9parer les headers de r\u00E9ponse (nettoyage CSP/Frame-Options)\n                let responseHeaders = new Headers(response.headers);\n                responseHeaders.delete(\"Content-Security-Policy\");\n                responseHeaders.delete(\"X-Frame-Options\");\n\n                // Gestion des redirections\n                if (response.headers.has('location')) {\n                    const location = response.headers.get('location');\n                    if (location.includes(TARGET_DOMAIN)) {\n                        const newLocation = location.replace(TARGET_DOMAIN, WORKER_DOMAIN);\n                        responseHeaders.set('location', newLocation);\n\n                        return new Response(response.body, {\n                            status: response.status,\n                            statusText: response.statusText,\n                            headers: responseHeaders\n                        });\n                    }\n                }\n\n                // R\u00E9\u00E9criture du contenu HTML\n                if (contentType && contentType.startsWith('text/html')) {\n                    return new HTMLRewriter()\n                        .on('a[href]', new AttributeRewriter('href', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('link[href]', new AttributeRewriter('href', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('script[src]', new AttributeRewriter('src', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('img[src]', new AttributeRewriter('src', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('img[srcset]', new AttributeRewriter('srcset', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('source[src]', new AttributeRewriter('src', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('source[srcset]', new AttributeRewriter('srcset', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .on('form[action]', new AttributeRewriter('action', TARGET_DOMAIN, WORKER_DOMAIN))\n                        .transform(new Response(response.body, {\n                            status: response.status,\n                            statusText: response.statusText,\n                            headers: responseHeaders\n                        }));\n                }\n\n                // Renvoyer les autres ressources telles quelles (images, css, etc.)\n                return new Response(response.body, {\n                    status: response.status,\n                    statusText: response.statusText,\n                    headers: responseHeaders\n                });\n\n\n\n            } catch (error) {\n                console.error(\"Erreur de reverse proxy:\", error);\n                return new Response(`Erreur de reverse proxy : ${error.message}`, { status: 500 });\n            }\n        }\n\n        // ====================================================================\n        // 6. FALLBACK - SERVIR INDEX.HTML PAR D\u00C9FAUT\n        // ====================================================================\n\n\n\n        try {\n            return await env.ASSETS.fetch(req);\n        } catch (e) {\n            return new Response(JSON.stringify({ error: \"Not Found\" }), { status: 404, headers: corsHeaders });\n        }\n    }\n};", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/_worker.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/macbookpro2015/.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/macbookpro2015/.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/_worker.js\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/.wrangler/tmp/bundle-ECyb65/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/macbookpro2015/.npm/_npx/32026684e21afda6/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/.wrangler/tmp/bundle-ECyb65/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/macbookpro2015/Documents/GitHub/StackPagesPortal/StackPagesPortal/.wrangler/tmp/bundle-ECyb65/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
